{% extends "base.html" %}

{% block title %}OCR Editor{% endblock %}

{% block content %}
<div class="row">
    <!-- Control Panel -->
    <div class="col-md-4 col-lg-3">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-cogs"></i> Controls</h5>
            </div>
            <div class="card-body">
                <button class="btn btn-success btn-sm w-100 mb-2" onclick="saveFile()">
                    <i class="fas fa-save"></i> Save Now (Auto-save: ON)
                </button>
                <button class="btn btn-primary btn-sm w-100 mb-2" id="validateBtn" onclick="toggleValidation()">
                    <i class="fas fa-check"></i> <span id="validateBtnText">Mark as Validated</span>
                </button>
                <button class="btn btn-info btn-sm w-100 mb-2" onclick="exportCurrentPage()">
                    <i class="fas fa-download"></i> Export Page
                </button>
                <button class="btn btn-primary btn-sm w-100 mb-2" onclick="addBoundingBox()">
                    <i class="fas fa-plus"></i> Add Bbox
                </button>
                <button class="btn btn-warning btn-sm w-100 mb-2" onclick="groupSelected()">
                    <i class="fas fa-object-group"></i> Group Selected
                </button>
                <button class="btn btn-secondary btn-sm w-100 mb-2" onclick="ungroupSelected()">
                    <i class="fas fa-object-ungroup"></i> Ungroup
                </button>
                <button class="btn btn-danger btn-sm w-100" onclick="deleteSelected()">
                    <i class="fas fa-trash"></i> Delete Selected
                </button>
                
                <hr>
                
                <div id="selectionInfo" class="text-center small text-muted">
                    <span id="selectionCount">0 boxes selected</span>
                </div>
                
                <hr>
                
                <h6>Reading Order</h6>
                <p class="small text-muted">Drag items to reorder</p>
                <div class="bbox-list" id="bboxList">
                    <!-- Bounding boxes will be populated here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Image Editor -->
    <div class="col-md-5 col-lg-6">
        <div class="card">
            <div class="card-header">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h5><i class="fas fa-image"></i> Document Editor</h5>
                    <div>
                        <button class="btn btn-outline-secondary btn-sm" onclick="zoomIn()">
                            <i class="fas fa-search-plus"></i>
                        </button>
                        <button class="btn btn-outline-secondary btn-sm" onclick="zoomOut()">
                            <i class="fas fa-search-minus"></i>
                        </button>
                        <button class="btn btn-outline-secondary btn-sm" onclick="resetZoom()">
                            <i class="fas fa-expand-arrows-alt"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Editor Mode Tabs -->
                <ul class="nav nav-tabs" id="editorTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="visual-tab" data-bs-toggle="tab" data-bs-target="#visual-pane" 
                                type="button" role="tab" onclick="switchEditorMode('visual')">
                            <i class="fas fa-vector-square"></i> Visual
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="text-tab" data-bs-toggle="tab" data-bs-target="#text-pane" 
                                type="button" role="tab" onclick="switchEditorMode('text')">
                            <i class="fas fa-edit"></i> Text Overlay
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="markdown-tab" data-bs-toggle="tab" data-bs-target="#markdown-pane" 
                                type="button" role="tab" onclick="switchEditorMode('markdown')">
                            <i class="fas fa-code"></i> Markdown
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="viewer-tab" data-bs-toggle="tab" data-bs-target="#viewer-pane" 
                                type="button" role="tab" onclick="switchEditorMode('viewer')">
                            <i class="fas fa-eye"></i> Viewer
                        </button>
                    </li>
                </ul>
            </div>
            <div class="card-body">
                <!-- Navigation Controls -->
                <div class="navigation-controls" id="navigationControls">
                    <div class="d-flex justify-content-between align-items-center">
                        <button class="btn btn-outline-primary btn-sm" onclick="navigateToAdjacentPage('prev')" id="prevBtn">
                            <i class="fas fa-chevron-left"></i> Previous
                        </button>
                        <div class="text-center">
                            <small class="text-muted" id="pageInfo">Page 1 of 1</small>
                            <br>
                            <small class="text-muted" id="folderInfo">Folder</small>
                        </div>
                        <button class="btn btn-outline-primary btn-sm" onclick="navigateToAdjacentPage('next')" id="nextBtn">
                            Next <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                    <div class="mt-2 text-center">
                        <small class="text-muted">Use sidebar for folder navigation</small>
                    </div>
                </div>
                
                <!-- Tab Content -->
                <div class="tab-content" id="editorTabContent">
                    <!-- Visual Editor Tab -->
                    <div class="tab-pane fade show active" id="visual-pane" role="tabpanel">
                        <div class="image-container" id="imageContainer">
                            <img id="mainImage" src="" alt="Document" style="max-width: 100%; height: auto;">
                            <!-- Bounding box overlays will be added here dynamically -->
                        </div>
                    </div>
                    
                    <!-- Text Overlay Editor Tab -->
                    <div class="tab-pane fade" id="text-pane" role="tabpanel">
                        <div class="text-overlay-container" id="textOverlayContainer">
                            <div class="position-relative">
                                <img id="textOverlayImage" src="" alt="Document" style="max-width: 100%; height: auto; opacity: 0.3;">
                                <div id="textOverlays">
                                    <!-- Text overlays will be positioned here -->
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Markdown Editor Tab -->
                    <div class="tab-pane fade" id="markdown-pane" role="tabpanel">
                        <div class="markdown-editor" id="markdownEditor">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6>Section-based Markdown Editor</h6>
                                <div>
                                    <button class="btn btn-primary btn-sm me-2" onclick="updateMarkdownFromText()">
                                        <i class="fas fa-sync"></i> Sync from Text
                                    </button>
                                    <button class="btn btn-success btn-sm" onclick="saveMarkdownChanges()">
                                        <i class="fas fa-save"></i> Save All Changes
                                    </button>
                                </div>
                            </div>
                            <div id="markdownSections" style="max-height: 500px; overflow-y: auto;">
                                <!-- Individual section cards will be populated here -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Viewer Tab -->
                    <div class="tab-pane fade" id="viewer-pane" role="tabpanel">
                        <div class="viewer-container" id="viewerContainer">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6>Document Viewer</h6>
                                <div class="btn-group btn-group-sm" role="group">
                                    <input type="radio" class="btn-check" name="viewerMode" id="viewerMarkdown" autocomplete="off" checked>
                                    <label class="btn btn-outline-secondary" for="viewerMarkdown" onclick="setViewerMode('markdown')">
                                        <i class="fas fa-code"></i> Markdown
                                    </label>
                                    
                                    <input type="radio" class="btn-check" name="viewerMode" id="viewerWebpage" autocomplete="off">
                                    <label class="btn btn-outline-secondary" for="viewerWebpage" onclick="setViewerMode('webpage')">
                                        <i class="fas fa-globe"></i> Web View
                                    </label>
                                </div>
                            </div>
                            <div id="viewerContent" style="height: 500px; overflow-y: auto; border: 1px solid #dee2e6; padding: 20px;">
                                <!-- Viewer content will appear here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Properties Panel -->
    <div class="col-md-3 col-lg-3">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-edit"></i> Properties</h5>
            </div>
            <div class="card-body">
                <div id="propertiesPanel">
                    <p class="text-muted">Select a bounding box to edit properties</p>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="loading d-none" id="loadingDiv">
    <i class="fas fa-spinner fa-spin fa-2x"></i>
    <p>Loading...</p>
</div>
{% endblock %}

{% block extra_js %}
<script>
let bboxData = [];
let selectedBboxes = [];
let currentZoom = 1;
let isUploaded = false;
let currentFilePath = '';
let currentImagePath = '';
let groups = {};
let nextGroupId = 1;
let currentPageInfo = null;
let isValidated = false;
let currentEditorMode = 'visual';
let markdownContent = '';
let viewerMode = 'markdown';

// Multi-selection variables
let isSelecting = false;
let selectionStart = {x: 0, y: 0};
let selectionBox = null;
let multiSelectedBoxes = [];
let justFinishedDrag = false;

// Auto-save functionality
let autoSaveTimeout = null;
const AUTO_SAVE_DELAY = 500; // 500ms delay after last change

// Categories from Flask app
const categories = {{ categories | tojson }};

// Initialize when page loads
$(document).ready(function() {
    const urlParams = new URLSearchParams(window.location.search);
    const jsonPath = urlParams.get('json_path');
    const imagePath = urlParams.get('image_path');
    isUploaded = urlParams.get('uploaded') === 'true';
    
    if (jsonPath && imagePath) {
        currentImagePath = imagePath;
        loadFileData(jsonPath, imagePath);
        
        // Set up tab click handlers to track current mode
        $('#editorTabs button[data-bs-toggle="tab"]').on('shown.bs.tab', function (e) {
            const targetTab = $(e.target).attr('data-bs-target');
            switch(targetTab) {
                case '#visual-pane':
                    currentEditorMode = 'visual';
                    break;
                case '#text-pane':
                    currentEditorMode = 'text';
                    break;
                case '#markdown-pane':
                    currentEditorMode = 'markdown';
                    break;
                case '#viewer-pane':
                    currentEditorMode = 'viewer';
                    break;
            }
            switchEditorMode(currentEditorMode);
        });
    }
    
    // Initialize sortable for reading order
    new Sortable(document.getElementById('bboxList'), {
        animation: 150,
        onEnd: function(evt) {
            updateReadingOrder();
        }
    });
});

function loadFileData(jsonPath, imagePath) {
    $('#loadingDiv').removeClass('d-none');
    
    // Set image source
    const imageUrl = isUploaded ? 
        `/api/image/${imagePath}` : 
        `/api/image/${imagePath}`;
    
    $('#mainImage').attr('src', imageUrl);
    
    // Load JSON data
    const loadUrl = isUploaded ? 
        `/api/load_file?path=${jsonPath}` :
        `/api/load_file?path=${jsonPath}`;
    
    fetch(loadUrl)
        .then(response => response.json())
        .then(data => {
            $('#loadingDiv').addClass('d-none');
            if (data.error) {
                alert('Error: ' + data.error);
            } else {
                bboxData = data.data;
                currentFilePath = data.file_path;
                isValidated = data.is_validated || false;
                
                // Update validation button
                updateValidationButton();
                
                // Update sidebar active state
                updateSidebarActiveState();
                
                // Update page info
                updateCurrentPageInfo();
                
                renderBoundingBoxes();
                updateBboxList();
                
                // Initialize drag selection after boxes are rendered
                initializeDragSelection();
            }
        })
        .catch(error => {
            $('#loadingDiv').addClass('d-none');
            alert('Error loading file: ' + error);
        });
}

function renderBoundingBoxes() {
    // Clear existing overlays
    $('.bbox-overlay').remove();
    
    const img = $('#mainImage')[0];
    const container = $('#imageContainer');
    
    const renderOverlays = () => {
        bboxData.forEach((bbox, index) => {
            createBboxOverlay(bbox, index);
        });
        
        // Update other editor modes after main image is loaded
        setTimeout(() => {
            updateAllEditorModes();
            // Reinitialize drag selection after boxes are rendered
            initializeDragSelection();
            // Update reading order numbers
            updateReadingOrderNumbers();
        }, 100);
    };
    
    // Wait for image to load
    img.onload = renderOverlays;
    
    // If image is already loaded
    if (img.complete) {
        renderOverlays();
    }
}

function createBboxOverlay(bbox, index) {
    const img = $('#mainImage')[0];
    const container = $('#imageContainer');
    
    if (!img.naturalWidth || !img.naturalHeight) return;
    
    const scaleX = img.clientWidth / img.naturalWidth;
    const scaleY = img.clientHeight / img.naturalHeight;
    
    const [x1, y1, x2, y2] = bbox.bbox;
    const left = x1 * scaleX;
    const top = y1 * scaleY;
    const width = (x2 - x1) * scaleX;
    const height = (y2 - y1) * scaleY;
    
    const overlay = $(`
        <div class="bbox-overlay" data-index="${index}" style="
            left: ${left}px;
            top: ${top}px;
            width: ${width}px;
            height: ${height}px;
        ">
            ${bbox.group_id ? `<div class="group-indicator">${bbox.group_id}</div>` : ''}
            <div class="resize-handle nw"></div>
            <div class="resize-handle ne"></div>
            <div class="resize-handle sw"></div>
            <div class="resize-handle se"></div>
        </div>
    `);
    
    // Add group styling if applicable
    if (bbox.group_id) {
        overlay.addClass('grouped');
    }
    
    container.append(overlay);
    
    // Add reading order number
    const readingOrderNumber = $(`<div class="reading-order-number">${bbox.reading_order || index + 1}</div>`);
    overlay.append(readingOrderNumber);
    
    // Add reading order controls
    const readingOrderControls = $(`
        <div class="reading-order-controls">
            <button class="reading-order-btn" onclick="moveReadingOrder(${index}, 'up')" title="Move up in reading order">
                <i class="fas fa-chevron-up"></i>
            </button>
            <button class="reading-order-btn" onclick="moveReadingOrder(${index}, 'down')" title="Move down in reading order">
                <i class="fas fa-chevron-down"></i>
            </button>
        </div>
    `);
    overlay.append(readingOrderControls);
    
    // Make draggable and resizable
    makeDraggable(overlay[0], index);
    makeResizable(overlay[0], index);
    
    // Click handler
    overlay.click(function(e) {
        e.stopPropagation();
        
        if (e.ctrlKey || e.metaKey) {
            // Multi-select with Cmd/Ctrl+click
            toggleBboxSelection(index);
        } else {
            // Single select
            selectBbox(index, false);
        }
    });
}

function makeDraggable(element, index) {
    let isDragging = false;
    let startX, startY, startLeft, startTop;
    
    element.addEventListener('mousedown', function(e) {
        if (e.target.classList.contains('resize-handle')) return;
        
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        startLeft = parseInt(element.style.left);
        startTop = parseInt(element.style.top);
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
        e.preventDefault();
    });
    
    function onMouseMove(e) {
        if (!isDragging) return;
        
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        element.style.left = (startLeft + dx) + 'px';
        element.style.top = (startTop + dy) + 'px';
    }
    
    function onMouseUp() {
        if (isDragging) {
            isDragging = false;
            updateBboxFromOverlay(element, index);
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        }
    }
}

function makeResizable(element, index) {
    const handles = element.querySelectorAll('.resize-handle');
    
    handles.forEach(handle => {
        handle.addEventListener('mousedown', function(e) {
            e.stopPropagation();
            
            const startX = e.clientX;
            const startY = e.clientY;
            const startWidth = parseInt(element.style.width);
            const startHeight = parseInt(element.style.height);
            const startLeft = parseInt(element.style.left);
            const startTop = parseInt(element.style.top);
            const handleClass = handle.className.split(' ')[1];
            
            function onMouseMove(e) {
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                let newWidth = startWidth;
                let newHeight = startHeight;
                let newLeft = startLeft;
                let newTop = startTop;
                
                switch(handleClass) {
                    case 'nw':
                        newWidth = startWidth - dx;
                        newHeight = startHeight - dy;
                        newLeft = startLeft + dx;
                        newTop = startTop + dy;
                        break;
                    case 'ne':
                        newWidth = startWidth + dx;
                        newHeight = startHeight - dy;
                        newTop = startTop + dy;
                        break;
                    case 'sw':
                        newWidth = startWidth - dx;
                        newHeight = startHeight + dy;
                        newLeft = startLeft + dx;
                        break;
                    case 'se':
                        newWidth = startWidth + dx;
                        newHeight = startHeight + dy;
                        break;
                }
                
                // Minimum size constraints
                if (newWidth > 10 && newHeight > 10) {
                    element.style.width = newWidth + 'px';
                    element.style.height = newHeight + 'px';
                    element.style.left = newLeft + 'px';
                    element.style.top = newTop + 'px';
                }
            }
            
            function onMouseUp() {
                updateBboxFromOverlay(element, index);
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
    });
}

function updateBboxFromOverlay(element, index) {
    const img = $('#mainImage')[0];
    
    if (!img.naturalWidth || !img.naturalHeight) return;
    
    const scaleX = img.naturalWidth / img.clientWidth;
    const scaleY = img.naturalHeight / img.clientHeight;
    
    const left = parseInt(element.style.left) * scaleX;
    const top = parseInt(element.style.top) * scaleY;
    const width = parseInt(element.style.width) * scaleX;
    const height = parseInt(element.style.height) * scaleY;
    
    bboxData[index].bbox = [
        Math.round(left),
        Math.round(top),
        Math.round(left + width),
        Math.round(top + height)
    ];
    
    updateBboxList();
    updatePropertiesPanel();
    autoSave(); // Auto-save after bbox modification
}

function selectBbox(index, multiSelect = false) {
    if (!multiSelect) {
        selectedBboxes = [index];
        $('.bbox-overlay').removeClass('selected');
        $('.bbox-item').removeClass('selected');
    } else {
        const existingIndex = selectedBboxes.indexOf(index);
        if (existingIndex > -1) {
            selectedBboxes.splice(existingIndex, 1);
        } else {
            selectedBboxes.push(index);
        }
    }
    
    // Update visual selection
    selectedBboxes.forEach(idx => {
        $(`.bbox-overlay[data-index="${idx}"]`).addClass('selected');
        $(`.bbox-item[data-index="${idx}"]`).addClass('selected');
    });
    
    updatePropertiesPanel();
}

function updateBboxList() {
    const list = $('#bboxList');
    list.empty();
    
    // Sort by reading order
    const sortedData = bboxData
        .map((bbox, index) => ({...bbox, originalIndex: index}))
        .sort((a, b) => (a.reading_order || 0) - (b.reading_order || 0));
    
    sortedData.forEach((bbox, listIndex) => {
        const item = $(`
            <div class="bbox-item" data-index="${bbox.originalIndex}">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <strong>${bbox.category || 'Unknown'}</strong>
                        ${bbox.group_id ? `<span class="badge bg-success ms-1">G${bbox.group_id}</span>` : ''}
                    </div>
                    <small>#${listIndex + 1}</small>
                </div>
                <div class="small text-muted mt-1">
                    ${bbox.text ? bbox.text.substring(0, 50) + (bbox.text.length > 50 ? '...' : '') : 'No text'}
                </div>
                <div class="small text-muted">
                    [${bbox.bbox.join(', ')}]
                </div>
            </div>
        `);
        
        item.click(function(e) {
            if (e.ctrlKey || e.metaKey) {
                toggleBboxSelection(bbox.originalIndex);
            } else {
                selectBbox(bbox.originalIndex, false);
            }
        });
        
        list.append(item);
    });
}

function updateReadingOrder() {
    const items = $('#bboxList .bbox-item');
    items.each(function(index) {
        const bboxIndex = parseInt($(this).data('index'));
        bboxData[bboxIndex].reading_order = index + 1; // Reading order starts from 1
    });
    
    // Update visual reading order numbers
    updateReadingOrderNumbers();
    autoSave();
}

function updatePropertiesPanel() {
    const panel = $('#propertiesPanel');
    
    if (selectedBboxes.length === 0) {
        panel.html('<p class="text-muted">Select a bounding box to edit properties</p>');
        return;
    }
    
    if (selectedBboxes.length === 1) {
        const bbox = bboxData[selectedBboxes[0]];
        panel.html(`
            <div class="mb-3">
                <label class="form-label">Category</label>
                <select class="form-select" id="categorySelect">
                    ${categories.map(cat => 
                        `<option value="${cat}" ${bbox.category === cat ? 'selected' : ''}>${cat}</option>`
                    ).join('')}
                </select>
            </div>
            <div class="mb-3">
                <label class="form-label">Text</label>
                <textarea class="form-control" id="textArea" rows="4">${bbox.text || ''}</textarea>
            </div>
            <div class="mb-3">
                <label class="form-label">Bounding Box</label>
                <div class="row">
                    <div class="col-6">
                        <input type="number" class="form-control form-control-sm" id="x1Input" 
                               placeholder="X1" value="${bbox.bbox[0]}">
                    </div>
                    <div class="col-6">
                        <input type="number" class="form-control form-control-sm" id="y1Input" 
                               placeholder="Y1" value="${bbox.bbox[1]}">
                    </div>
                </div>
                <div class="row mt-1">
                    <div class="col-6">
                        <input type="number" class="form-control form-control-sm" id="x2Input" 
                               placeholder="X2" value="${bbox.bbox[2]}">
                    </div>
                    <div class="col-6">
                        <input type="number" class="form-control form-control-sm" id="y2Input" 
                               placeholder="Y2" value="${bbox.bbox[3]}">
                    </div>
                </div>
            </div>
            <button class="btn btn-primary btn-sm w-100" onclick="applyProperties()">
                Apply Changes
            </button>
        `);
    } else {
        panel.html(`
            <p class="text-muted">${selectedBboxes.length} bounding boxes selected</p>
            <div class="mb-3">
                <label class="form-label">Category (bulk edit)</label>
                <select class="form-select" id="bulkCategorySelect">
                    <option value="">-- No change --</option>
                    ${categories.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
                </select>
            </div>
            <button class="btn btn-primary btn-sm w-100" onclick="applyBulkProperties()">
                Apply to Selected
            </button>
        `);
    }
}

function applyProperties() {
    if (selectedBboxes.length !== 1) return;
    
    const index = selectedBboxes[0];
    const bbox = bboxData[index];
    
    bbox.category = $('#categorySelect').val();
    bbox.text = $('#textArea').val();
    bbox.bbox = [
        parseInt($('#x1Input').val()),
        parseInt($('#y1Input').val()),
        parseInt($('#x2Input').val()),
        parseInt($('#y2Input').val())
    ];
    
    renderBoundingBoxes();
    updateBboxList();
    autoSave(); // Auto-save property changes
}

function applyBulkProperties() {
    const category = $('#bulkCategorySelect').val();
    
    if (category) {
        selectedBboxes.forEach(index => {
            bboxData[index].category = category;
        });
    }
    
    renderBoundingBoxes();
    updateBboxList();
    updatePropertiesPanel();
    autoSave(); // Auto-save bulk changes
}

function groupSelected() {
    if (selectedBboxes.length < 2) {
        alert('Please select at least 2 bounding boxes to group.');
        return;
    }
    
    const groupId = nextGroupId++;
    selectedBboxes.forEach(index => {
        bboxData[index].group_id = groupId;
    });
    
    groups[groupId] = [...selectedBboxes];
    renderBoundingBoxes();
    updateBboxList();
    autoSave(); // Auto-save grouping changes
}

function ungroupSelected() {
    selectedBboxes.forEach(index => {
        const bbox = bboxData[index];
        if (bbox.group_id) {
            delete groups[bbox.group_id];
            delete bbox.group_id;
        }
    });
    
    renderBoundingBoxes();
    updateBboxList();
    autoSave(); // Auto-save ungrouping changes
}

function deleteSelected() {
    if (selectedBboxes.length === 0) return;
    
    if (!confirm(`Delete ${selectedBboxes.length} bounding box(es)?`)) return;
    
    // Sort indices in descending order to avoid index shifting issues
    selectedBboxes.sort((a, b) => b - a);
    
    selectedBboxes.forEach(index => {
        bboxData.splice(index, 1);
    });
    
    selectedBboxes = [];
    renderBoundingBoxes();
    updateBboxList();
    updatePropertiesPanel();
    autoSave(); // Auto-save deletion changes
}

function addBoundingBox() {
    const newBbox = {
        bbox: [100, 100, 200, 150],
        category: 'Text',
        text: '',
        reading_order: bboxData.length
    };
    
    bboxData.push(newBbox);
    renderBoundingBoxes();
    updateBboxList();
    autoSave(); // Auto-save new bounding box
}

function saveFile() {
    if (!currentFilePath) {
        alert('No file loaded to save.');
        return;
    }
    
    $('#loadingDiv').removeClass('d-none');
    
    fetch('/api/save_file', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            file_path: currentFilePath,
            data: bboxData
        })
    })
    .then(response => response.json())
    .then(data => {
        $('#loadingDiv').addClass('d-none');
        if (data.error) {
            alert('Error saving: ' + data.error);
        } else {
            // Show success message with save type
            const message = data.saved_to_file ? 
                'File saved to database and filesystem!' : 
                'File saved to database!';
            
            // Create a temporary success indicator
            const saveBtn = $('button:contains("Save Changes")');
            const originalText = saveBtn.html();
            saveBtn.html('<i class="fas fa-check"></i> Saved!').removeClass('btn-success').addClass('btn-outline-success');
            
            setTimeout(() => {
                saveBtn.html(originalText).removeClass('btn-outline-success').addClass('btn-success');
            }, 2000);
        }
    })
    .catch(error => {
        $('#loadingDiv').addClass('d-none');
        alert('Error saving file: ' + error);
    });
}

function autoSave() {
    // Clear any existing timeout
    if (autoSaveTimeout) {
        clearTimeout(autoSaveTimeout);
    }
    
    // Set a new timeout to save after delay
    autoSaveTimeout = setTimeout(() => {
        console.log('Auto-saving changes...');
        saveFileQuiet(); // Use quiet version for auto-save
    }, AUTO_SAVE_DELAY);
}

function saveFileQuiet() {
    if (!currentFilePath) return;
    
    fetch('/api/save_file', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            file_path: currentFilePath,
            data: bboxData
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            console.error('Auto-save error:', data.error);
        } else {
            console.log('Auto-saved successfully');
        }
    })
    .catch(error => {
        console.error('Auto-save error:', error);
    });
}

function toggleValidation() {
    if (!currentFilePath) {
        alert('No file loaded.');
        return;
    }
    
    const newValidationStatus = !isValidated;
    
    fetch('/api/validate_page', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            file_path: currentFilePath,
            is_validated: newValidationStatus
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            alert('Error updating validation: ' + data.error);
        } else {
            isValidated = data.is_validated;
            updateValidationButton();
            
            const message = isValidated ? 'Page marked as validated!' : 'Page unmarked as validated!';
            
            // Show temporary success message
            const validateBtn = $('#validateBtn');
            const originalContent = validateBtn.html();
            validateBtn.html('<i class="fas fa-check"></i> ' + (isValidated ? 'Validated!' : 'Unvalidated!'));
            
            setTimeout(() => {
                validateBtn.html(originalContent);
            }, 2000);
        }
    })
    .catch(error => {
        alert('Error updating validation: ' + error);
    });
}

function updateValidationButton() {
    const btn = $('#validateBtn');
    const text = $('#validateBtnText');
    
    if (isValidated) {
        btn.removeClass('btn-primary').addClass('btn-warning');
        text.text('Remove Validation');
        btn.find('i').removeClass('fa-check').addClass('fa-times');
    } else {
        btn.removeClass('btn-warning').addClass('btn-primary');
        text.text('Mark as Validated');
        btn.find('i').removeClass('fa-times').addClass('fa-check');
    }
}

function exportCurrentPage() {
    if (!currentFilePath) {
        alert('No file loaded to export.');
        return;
    }
    
    fetch('/api/export', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            export_type: 'page',
            export_scope: currentFilePath
        })
    })
    .then(response => {
        if (response.ok) {
            return response.blob();
        }
        throw new Error('Export failed');
    })
    .then(blob => {
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        
        const filename = currentFilePath.split('/').pop().replace('.json', '');
        a.download = `page_${filename}_${new Date().toISOString().slice(0,19).replace(/:/g, '')}.zip`;
        
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        
        // Show success message
        const exportBtn = $('button:contains("Export Page")');
        const originalText = exportBtn.html();
        exportBtn.html('<i class="fas fa-check"></i> Exported!').removeClass('btn-info').addClass('btn-outline-info');
        
        setTimeout(() => {
            exportBtn.html(originalText).removeClass('btn-outline-info').addClass('btn-info');
        }, 2000);
    })
    .catch(error => {
        alert('Error exporting page: ' + error.message);
    });
}

function zoomIn() {
    currentZoom *= 1.2;
    applyZoom();
}

function zoomOut() {
    currentZoom /= 1.2;
    applyZoom();
}

function resetZoom() {
    currentZoom = 1;
    applyZoom();
}

function applyZoom() {
    const img = $('#mainImage');
    img.css('transform', `scale(${currentZoom})`);
    img.css('transform-origin', 'top left');
    
    // Re-render bounding boxes after zoom
    setTimeout(() => {
        renderBoundingBoxes();
    }, 100);
}

// Navigation functions
function updateSidebarActiveState() {
    if (currentFilePath) {
        // Update active page in sidebar
        document.querySelectorAll('.page-item').forEach(p => p.classList.remove('active'));
        const activePageItem = document.querySelector(`[data-json-path="${currentFilePath}"]`);
        if (activePageItem) {
            activePageItem.classList.add('active');
            
            // Expand the parent folder
            const folderItem = activePageItem.closest('.folder-item');
            if (folderItem) {
                document.querySelectorAll('.folder-item').forEach(f => f.classList.remove('active'));
                folderItem.classList.add('active');
            }
        }
    }
}

function updateCurrentPageInfo() {
    if (currentFilePath && window.folderData) {
        // Find current page info from folderData
        for (const [folderName, files] of Object.entries(window.folderData)) {
            const pageIndex = files.findIndex(f => f.json_path === currentFilePath);
            if (pageIndex !== -1) {
                const currentPage = pageIndex + 1;
                const totalPages = files.length;
                
                $('#pageInfo').text(`Page ${currentPage} of ${totalPages}`);
                $('#folderInfo').text(folderName);
                
                // Update navigation buttons
                $('#prevBtn').prop('disabled', pageIndex === 0);
                $('#nextBtn').prop('disabled', pageIndex === files.length - 1);
                
                return;
            }
        }
    }
}

function navigateToAdjacentPage(direction) {
    if (!currentFilePath || !window.folderData) return;
    
    // Find current page in folderData
    for (const [folderName, files] of Object.entries(window.folderData)) {
        const pageIndex = files.findIndex(f => f.json_path === currentFilePath);
        if (pageIndex !== -1) {
            let newIndex;
            if (direction === 'next' && pageIndex < files.length - 1) {
                newIndex = pageIndex + 1;
            } else if (direction === 'prev' && pageIndex > 0) {
                newIndex = pageIndex - 1;
            } else {
                return; // Can't navigate further
            }
            
            const newFile = files[newIndex];
            currentImagePath = newFile.image_path;
            loadFileData(newFile.json_path, newFile.image_path);
            
            // Ensure current editor mode is refreshed after navigation
            setTimeout(() => {
                switchEditorMode(currentEditorMode);
            }, 200);
            
            // Update URL
            const newUrl = new URLSearchParams({
                json_path: newFile.json_path,
                image_path: newFile.image_path
            });
            window.history.pushState({}, '', '/editor?' + newUrl.toString());
            
            return;
        }
    }
}

function navigatePage(direction) {
    if (!currentFilePath || isUploaded) return;
    
    $('#loadingDiv').removeClass('d-none');
    
    fetch(`/api/navigate?current_path=${encodeURIComponent(currentFilePath)}&direction=${direction}`)
        .then(response => response.json())
        .then(data => {
            $('#loadingDiv').addClass('d-none');
            if (data.error) {
                alert('Error: ' + data.error);
            } else {
                // Update current paths
                currentFilePath = data.json_path;
                currentImagePath = data.image_path;
                currentPageInfo = data;
                
                // Update URL without reload
                const newUrl = new URLSearchParams({
                    json_path: data.json_path,
                    image_path: data.image_path
                });
                window.history.pushState({}, '', '/editor?' + newUrl.toString());
                
                // Load new data
                loadFileData(data.json_path, data.image_path);
                
                // Refresh current editor mode after navigation
                setTimeout(() => {
                    switchEditorMode(currentEditorMode);
                }, 200);
            }
        })
        .catch(error => {
            $('#loadingDiv').addClass('d-none');
            alert('Error navigating: ' + error);
        });
}

function jumpToPage() {
    const pageNum = parseInt($('#pageJump').val());
    if (!pageNum || !currentPageInfo) return;
    
    if (pageNum < 1 || pageNum > currentPageInfo.total_pages) {
        alert(`Please enter a page number between 1 and ${currentPageInfo.total_pages}`);
        return;
    }
    
    // Calculate how many steps to navigate
    const currentPage = currentPageInfo.current_page;
    const steps = pageNum - currentPage;
    
    if (steps === 0) return;
    
    const direction = steps > 0 ? 'next' : 'prev';
    const absoluteSteps = Math.abs(steps);
    
    // Navigate step by step (could be optimized with a direct jump API)
    let stepCount = 0;
    function navigateStep() {
        if (stepCount >= absoluteSteps) return;
        
        stepCount++;
        navigatePage(direction);
        
        // Wait a bit before next step to ensure completion
        if (stepCount < absoluteSteps) {
            setTimeout(navigateStep, 500);
        }
    }
    
    navigateStep();
}

function updatePageInfo() {
    if (!currentPageInfo) {
        // Try to get page info from current path
        fetch(`/api/navigate?current_path=${encodeURIComponent(currentFilePath)}&direction=next`)
            .then(response => response.json())
            .then(data => {
                if (!data.error) {
                    // Navigate back to get current info
                    fetch(`/api/navigate?current_path=${encodeURIComponent(data.json_path)}&direction=prev`)
                        .then(response => response.json())
                        .then(currentData => {
                            if (!currentData.error) {
                                currentPageInfo = currentData;
                                displayPageInfo();
                            }
                        });
                }
            });
    } else {
        displayPageInfo();
    }
}

function displayPageInfo() {
    if (currentPageInfo) {
        $('#pageInfo').text(`Page ${currentPageInfo.current_page} of ${currentPageInfo.total_pages}`);
        $('#folderInfo').text(currentPageInfo.folder);
        $('#pageJump').attr('max', currentPageInfo.total_pages);
        $('#pageJump').val(currentPageInfo.current_page);
    }
}

// Editor Mode Functions
function switchEditorMode(mode) {
    currentEditorMode = mode;
    
    // Always update all modes when switching to ensure consistency
    updateAllEditorModes();
}

function updateAllEditorModes() {
    // Ensure main image is loaded first
    const mainImg = $('#mainImage')[0];
    
    const doUpdate = () => {
        // Update text overlay image source
        updateTextOverlayImage();
        
        // Update content for all modes
        updateTextOverlays();
        updateMarkdownFromText();
        updateViewer();
    };
    
    if (mainImg && mainImg.complete && mainImg.naturalWidth > 0) {
        // Image is already loaded
        doUpdate();
    } else if (mainImg) {
        // Wait for image to load
        mainImg.onload = doUpdate;
        // Also try after a short delay in case the event was missed
        setTimeout(doUpdate, 100);
    } else {
        // No main image, update what we can
        updateMarkdownFromText();
        updateViewer();
    }
}

function updateTextOverlayImage() {
    const mainImageSrc = $('#mainImage').attr('src');
    if (mainImageSrc) {
        $('#textOverlayImage').attr('src', mainImageSrc);
    }
}

function updateTextOverlays() {
    const container = $('#textOverlays');
    const img = $('#textOverlayImage')[0];
    
    container.empty();
    
    if (!bboxData.length) return;
    
    // Ensure the text overlay image has the same source as main image
    updateTextOverlayImage();
    
    // Wait for image to load
    const renderOverlays = () => {
        if (!img.naturalWidth || !img.naturalHeight) return;
        
        const scaleX = img.clientWidth / img.naturalWidth;
        const scaleY = img.clientHeight / img.naturalHeight;
        
        // Sort by reading order
        const sortedData = bboxData
            .filter(bbox => bbox.text && bbox.text.trim())
            .sort((a, b) => (a.reading_order || 0) - (b.reading_order || 0));
        
        sortedData.forEach((bbox, index) => {
            const [x1, y1, x2, y2] = bbox.bbox;
            const left = x1 * scaleX;
            const top = y1 * scaleY;
            const width = (x2 - x1) * scaleX;
            const height = (y2 - y1) * scaleY;
            
            const textOverlay = $(`
                <div class="text-overlay-item" 
                     data-bbox-index="${bboxData.indexOf(bbox)}"
                     contenteditable="true"
                     style="left: ${left}px; top: ${top}px; width: ${width}px; height: ${height}px;">
                    ${bbox.text || ''}
                </div>
            `);
            
            // Handle text editing
            textOverlay.on('focus', function() {
                $(this).addClass('editing');
            });
            
            textOverlay.on('blur', function() {
                $(this).removeClass('editing');
                const bboxIndex = parseInt($(this).data('bbox-index'));
                const newText = $(this).text();
                if (bboxData[bboxIndex]) {
                    bboxData[bboxIndex].text = newText;
                    updateBboxList();
                    autoSave(); // Auto-save text overlay changes
                }
            });
            
            textOverlay.on('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    $(this).blur();
                }
            });
            
            container.append(textOverlay);
        });
    };
    
    if (img.complete) {
        renderOverlays();
    } else {
        img.onload = renderOverlays;
    }
}

function updateMarkdownFromText() {
    const container = $('#markdownSections');
    container.empty();
    
    if (!bboxData.length) {
        container.html('<div class="text-muted text-center p-4">No text content available</div>');
        return;
    }
    
    // Sort by reading order
    const sortedData = bboxData
        .filter(bbox => bbox.text && bbox.text.trim())
        .sort((a, b) => (a.reading_order || 0) - (b.reading_order || 0));
    
    sortedData.forEach((bbox, index) => {
        const text = bbox.text.trim();
        const category = bbox.category;
        const originalIndex = bboxData.indexOf(bbox);
        
        // Generate markdown for this section based on category
        let markdown = '';
        let categoryClass = 'secondary';
        
        switch(category) {
            case 'Title':
                markdown = `# ${text}`;
                categoryClass = 'primary';
                break;
            case 'Section-header':
                markdown = `## ${text}`;
                categoryClass = 'info';
                break;
            case 'List-item':
                markdown = `- ${text}`;
                categoryClass = 'warning';
                break;
            case 'Formula':
                markdown = `\`\`\`\n${text}\n\`\`\``;
                categoryClass = 'dark';
                break;
            case 'Caption':
                markdown = `*${text}*`;
                categoryClass = 'light';
                break;
            case 'Footnote':
                markdown = `> ${text}`;
                categoryClass = 'secondary';
                break;
            case 'Page-header':
            case 'Page-footer':
                markdown = `---\n${text}\n---`;
                categoryClass = 'secondary';
                break;
            default:
                markdown = text;
                categoryClass = 'success';
        }
        
        const sectionCard = $(`
            <div class="markdown-section-card" data-bbox-index="${originalIndex}">
                <div class="markdown-section-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <span class="reading-order-badge">${index + 1}</span>
                            <span class="badge bg-${categoryClass} category-badge">${category}</span>
                        </div>
                        <div>
                            <button class="btn btn-outline-secondary btn-sm" onclick="moveSection(${originalIndex}, 'up')" 
                                    ${index === 0 ? 'disabled' : ''}>
                                <i class="fas fa-arrow-up"></i>
                            </button>
                            <button class="btn btn-outline-secondary btn-sm" onclick="moveSection(${originalIndex}, 'down')" 
                                    ${index === sortedData.length - 1 ? 'disabled' : ''}>
                                <i class="fas fa-arrow-down"></i>
                            </button>
                            <button class="btn btn-outline-danger btn-sm" onclick="deleteSection(${originalIndex})">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="markdown-section-content">
                    <textarea class="form-control markdown-section-textarea" 
                              data-bbox-index="${originalIndex}"
                              placeholder="Enter markdown for this section..."
                              rows="${Math.max(2, Math.ceil(markdown.length / 50))}">${markdown}</textarea>
                </div>
            </div>
        `);
        
        container.append(sectionCard);
    });
    
    // Add event listeners for textarea changes
    $('.markdown-section-textarea').on('input', function() {
        const bboxIndex = parseInt($(this).data('bbox-index'));
        const markdownText = $(this).val();
        
        // Convert markdown back to plain text for the bbox
        const plainText = markdownText
            .replace(/^#{1,6}\s+/, '') // Remove headers
            .replace(/^\-\s+/, '') // Remove list items
            .replace(/^\>\s+/, '') // Remove blockquotes
            .replace(/^\*(.+)\*$/, '$1') // Remove emphasis
            .replace(/^---\n?/, '').replace(/\n?---$/, '') // Remove horizontal rules
            .replace(/```\n?/, '').replace(/\n?```/, '') // Remove code blocks
            .trim();
        
        if (bboxData[bboxIndex]) {
            bboxData[bboxIndex].text = plainText;
            
            // Update viewer in real-time
            updateViewer();
            
            // Auto-save text changes
            autoSave();
        }
    });
}

function saveMarkdownChanges() {
    // All changes are already saved in real-time via textarea input events
    // Just update other components and save to database
    updateBboxList();
    updateTextOverlays();
    updateViewer();
    
    // Save to database
    autoSave();
    
    // Show success feedback
    const saveBtn = $('button:contains("Save All Changes")');
    const originalText = saveBtn.html();
    saveBtn.html('<i class="fas fa-check"></i> Saved!').removeClass('btn-success').addClass('btn-outline-success');
    
    setTimeout(() => {
        saveBtn.html(originalText).removeClass('btn-outline-success').addClass('btn-success');
    }, 2000);
}

function moveSection(bboxIndex, direction) {
    const currentOrder = bboxData[bboxIndex].reading_order || 0;
    
    // Find the section to swap with
    let swapIndex = -1;
    if (direction === 'up') {
        // Find previous section in reading order
        for (let i = 0; i < bboxData.length; i++) {
            if (i !== bboxIndex && (bboxData[i].reading_order || 0) === currentOrder - 1) {
                swapIndex = i;
                break;
            }
        }
    } else {
        // Find next section in reading order
        for (let i = 0; i < bboxData.length; i++) {
            if (i !== bboxIndex && (bboxData[i].reading_order || 0) === currentOrder + 1) {
                swapIndex = i;
                break;
            }
        }
    }
    
    if (swapIndex !== -1) {
        // Swap reading orders
        const tempOrder = bboxData[bboxIndex].reading_order;
        bboxData[bboxIndex].reading_order = bboxData[swapIndex].reading_order;
        bboxData[swapIndex].reading_order = tempOrder;
        
        // Update all views
        updateMarkdownFromText();
        updateBboxList();
        updateTextOverlays();
    }
}

function deleteSection(bboxIndex) {
    if (!confirm('Are you sure you want to delete this section?')) return;
    
    // Remove the bounding box
    bboxData.splice(bboxIndex, 1);
    
    // Update reading order for remaining items
    bboxData.forEach((bbox, index) => {
        bbox.reading_order = index;
    });
    
    // Update all views
    updateMarkdownFromText();
    updateBboxList();
    updateTextOverlays();
    renderBoundingBoxes();
}

function updateViewer() {
    const content = $('#viewerContent');
    
    // Generate markdown from current sections
    let fullMarkdown = '';
    $('.markdown-section-textarea').each(function() {
        const sectionMarkdown = $(this).val().trim();
        if (sectionMarkdown) {
            fullMarkdown += sectionMarkdown + '\n\n';
        }
    });
    
    if (viewerMode === 'markdown') {
        // Show raw markdown
        content.html(`<pre style="white-space: pre-wrap; font-family: 'Courier New', monospace;">${fullMarkdown}</pre>`);
    } else {
        // Show rendered HTML
        const html = marked.parse(fullMarkdown);
        content.html(`<div class="viewer-content">${html}</div>`);
    }
}

function setViewerMode(mode) {
    viewerMode = mode;
    updateViewer();
}

// Multi-selection functions
function initializeDragSelection() {
    const container = $('#imageContainer');
    
    console.log('Initializing drag selection on container:', container.length);
    
    // Remove existing handlers to avoid duplicates
    container.off('mousedown.dragselect');
    $(document).off('mousemove.dragselect mouseup.dragselect');
    
    container.on('mousedown.dragselect', function(e) {
        console.log('Mouse down on container, target:', e.target.tagName, e.target.className);
        // Only start drag selection if clicking on the container itself, not on a bbox
        if (e.target === this || e.target.tagName === 'IMG') {
            console.log('Starting drag selection from container click');
            startDragSelection(e);
        }
    });
    
    $(document).on('mousemove.dragselect', function(e) {
        if (isSelecting) {
            updateDragSelection(e);
        }
    });
    
    $(document).on('mouseup.dragselect', function(e) {
        if (isSelecting) {
            endDragSelection(e);
        }
    });
}

function startDragSelection(e) {
    if (e.ctrlKey || e.metaKey) return; // Don't start drag selection with modifier keys
    
    console.log('Starting drag selection');
    isSelecting = true;
    const container = $('#imageContainer');
    const containerOffset = container.offset();
    
    selectionStart = {
        x: e.pageX - containerOffset.left,
        y: e.pageY - containerOffset.top
    };
    
    console.log('Selection start:', selectionStart);
    
    // Clear previous selection if not holding Shift
    if (!e.shiftKey) {
        clearMultiSelection();
    }
    
    // Create selection box
    selectionBox = $('<div class="selection-box"></div>');
    container.append(selectionBox);
    
    // Prevent text selection
    e.preventDefault();
}

function updateDragSelection(e) {
    if (!isSelecting || !selectionBox) return;
    
    const container = $('#imageContainer');
    const containerOffset = container.offset();
    
    const currentX = e.pageX - containerOffset.left;
    const currentY = e.pageY - containerOffset.top;
    
    const left = Math.min(selectionStart.x, currentX);
    const top = Math.min(selectionStart.y, currentY);
    const width = Math.abs(currentX - selectionStart.x);
    const height = Math.abs(currentY - selectionStart.y);
    
    selectionBox.css({
        left: left + 'px',
        top: top + 'px',
        width: width + 'px',
        height: height + 'px'
    });
    
    // Highlight overlapping bounding boxes
    highlightOverlappingBoxes(left, top, width, height);
}

function endDragSelection(e) {
    if (!isSelecting) return;
    
    console.log('Ending drag selection, selected boxes:', multiSelectedBoxes);
    isSelecting = false;
    
    // Set flag to prevent immediate clearing by click outside handler
    justFinishedDrag = true;
    
    // Remove selection box
    if (selectionBox) {
        selectionBox.remove();
        selectionBox = null;
    }
    
    // Finalize selection - make sure selectedBboxes is updated
    selectedBboxes = [...multiSelectedBoxes];
    
    // Update visual indicators
    updateVisualSelection();
    updateSelectionCounter();
    updatePropertiesPanel();
    
    console.log('Final selection state:', selectedBboxes, multiSelectedBoxes);
    
    // Clear the flag after a short delay
    setTimeout(() => {
        justFinishedDrag = false;
    }, 100);
}

function highlightOverlappingBoxes(selectionLeft, selectionTop, selectionWidth, selectionHeight) {
    // Start fresh for this drag operation
    let dragSelectedBoxes = [];
    
    $('.bbox-overlay').each(function() {
        const bbox = $(this);
        const bboxLeft = parseInt(bbox.css('left'));
        const bboxTop = parseInt(bbox.css('top'));
        const bboxWidth = parseInt(bbox.css('width'));
        const bboxHeight = parseInt(bbox.css('height'));
        
        // Check if bounding boxes overlap
        const overlap = !(selectionLeft > bboxLeft + bboxWidth ||
                         selectionLeft + selectionWidth < bboxLeft ||
                         selectionTop > bboxTop + bboxHeight ||
                         selectionTop + selectionHeight < bboxTop);
        
        const index = parseInt(bbox.data('index'));
        
        if (overlap) {
            bbox.addClass('multi-selected');
            dragSelectedBoxes.push(index);
        } else {
            bbox.removeClass('multi-selected');
        }
    });
    
    // Update the selection array with drag results
    multiSelectedBoxes = dragSelectedBoxes;
    
    // Debug log
    console.log('Drag selection - overlapping boxes:', multiSelectedBoxes);
}

function toggleBboxSelection(index) {
    console.log('Toggling bbox selection for index:', index);
    const bbox = $(`.bbox-overlay[data-index="${index}"]`);
    const isCurrentlySelected = multiSelectedBoxes.includes(index);
    
    console.log('Currently selected:', isCurrentlySelected, 'Multi-selected boxes:', multiSelectedBoxes);
    
    if (isCurrentlySelected) {
        // Remove from selection
        multiSelectedBoxes = multiSelectedBoxes.filter(i => i !== index);
        bbox.removeClass('multi-selected selected');
        $(`.bbox-item[data-index="${index}"]`).removeClass('selected');
        console.log('Removed from selection');
    } else {
        // Add to selection
        multiSelectedBoxes.push(index);
        bbox.addClass('multi-selected');
        $(`.bbox-item[data-index="${index}"]`).addClass('selected');
        console.log('Added to selection');
    }
    
    console.log('New multi-selected boxes:', multiSelectedBoxes);
    
    // Update selectedBboxes for compatibility with existing functions
    selectedBboxes = [...multiSelectedBoxes];
    updateSelectionCounter();
    updatePropertiesPanel();
}

function selectBbox(index, multiSelect = false) {
    if (!multiSelect) {
        // Clear all selections
        clearMultiSelection();
        selectedBboxes = [index];
        multiSelectedBoxes = [index];
    } else {
        // Add to existing selection
        if (!selectedBboxes.includes(index)) {
            selectedBboxes.push(index);
            multiSelectedBoxes.push(index);
        }
    }
    
    // Update visual selection
    updateVisualSelection();
    updateSelectionCounter();
    updatePropertiesPanel();
}

function clearMultiSelection() {
    console.log('clearMultiSelection called - clearing', multiSelectedBoxes.length, 'boxes');
    console.trace('clearMultiSelection call stack');
    
    multiSelectedBoxes = [];
    selectedBboxes = [];
    $('.bbox-overlay').removeClass('selected multi-selected');
    $('.bbox-item').removeClass('selected');
    updateSelectionCounter();
}

function finalizeMultiSelection() {
    // Update selectedBboxes for compatibility
    selectedBboxes = [...multiSelectedBoxes];
    
    // Update visual indicators
    updateVisualSelection();
}

function updateVisualSelection() {
    console.log('Updating visual selection for boxes:', multiSelectedBoxes);
    
    // Clear all visual selections first
    $('.bbox-overlay').removeClass('selected multi-selected');
    $('.bbox-item').removeClass('selected');
    
    // Apply selections
    multiSelectedBoxes.forEach(index => {
        const overlay = $(`.bbox-overlay[data-index="${index}"]`);
        const listItem = $(`.bbox-item[data-index="${index}"]`);
        
        overlay.addClass('multi-selected');
        listItem.addClass('selected');
        
        console.log(`Applied multi-selected to box ${index}:`, overlay.length > 0);
    });
}

function selectAllBboxes() {
    multiSelectedBoxes = [];
    selectedBboxes = [];
    
    // Select all available bounding boxes
    $('.bbox-overlay').each(function() {
        const index = parseInt($(this).data('index'));
        if (!isNaN(index)) {
            multiSelectedBoxes.push(index);
            selectedBboxes.push(index);
        }
    });
    
    updateVisualSelection();
    updateSelectionCounter();
    updatePropertiesPanel();
}

function updateSelectionCounter() {
    const count = multiSelectedBoxes.length;
    const countText = count === 0 ? '0 boxes selected' : 
                     count === 1 ? '1 box selected' : 
                     `${count} boxes selected`;
    $('#selectionCount').text(countText);
    
    // Also update the console for debugging
    console.log('Selection counter updated:', countText);
}

function moveReadingOrder(bboxIndex, direction) {
    console.log(`Moving box ${bboxIndex} ${direction} in reading order`);
    
    // Find current position in reading order
    const currentOrder = bboxData[bboxIndex].reading_order || bboxIndex + 1;
    let newOrder;
    
    if (direction === 'up') {
        newOrder = Math.max(1, currentOrder - 1);
    } else {
        newOrder = Math.min(bboxData.length, currentOrder + 1);
    }
    
    // If no change needed, return
    if (newOrder === currentOrder) return;
    
    // Find the box that currently has the target reading order
    const targetBox = bboxData.find(box => (box.reading_order || bboxData.indexOf(box) + 1) === newOrder);
    
    if (targetBox) {
        // Swap reading orders
        const targetIndex = bboxData.indexOf(targetBox);
        targetBox.reading_order = currentOrder;
        bboxData[bboxIndex].reading_order = newOrder;
        
        console.log(`Swapped reading orders: box ${bboxIndex} (${currentOrder} -> ${newOrder}), box ${targetIndex} (${newOrder} -> ${currentOrder})`);
    } else {
        // Just set the new reading order
        bboxData[bboxIndex].reading_order = newOrder;
    }
    
    // Update visual elements
    updateReadingOrderNumbers();
    updateBboxList();
    
    // Save changes
    autoSave();
}

function updateReadingOrderNumbers() {
    $('.bbox-overlay').each(function() {
        const index = parseInt($(this).data('index'));
        const bbox = bboxData[index];
        const readingOrder = bbox.reading_order || index + 1;
        
        $(this).find('.reading-order-number').text(readingOrder);
    });
}

// Remove old markdown textarea reference - now handled in updateMarkdownFromText()

// Keyboard shortcuts
$(document).keydown(function(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    switch(e.key) {
        case 'ArrowLeft':
            e.preventDefault();
            navigatePage('prev');
            break;
        case 'ArrowRight':
            e.preventDefault();
            navigatePage('next');
            break;
        case 's':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                autoSave();
            }
            break;
        case '1':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                $('#visual-tab').click();
            }
            break;
        case '2':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                $('#text-tab').click();
            }
            break;
        case '3':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                $('#markdown-tab').click();
            }
            break;
        case '4':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                $('#viewer-tab').click();
            }
            break;
        case 'a':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                selectAllBboxes();
            }
            break;
        case 'Escape':
            clearMultiSelection();
            updatePropertiesPanel();
            break;
    }
});

// Click outside to deselect
$(document).click(function(e) {
    // Don't clear selection if we just finished a drag operation
    if (justFinishedDrag) {
        justFinishedDrag = false;
        return;
    }
    
    if (!$(e.target).closest('.bbox-overlay, .bbox-item, .selection-box, #imageContainer').length && !isSelecting) {
        console.log('Clicking outside - clearing selection');
        clearMultiSelection();
        updatePropertiesPanel();
    }
});
</script>
{% endblock %}
